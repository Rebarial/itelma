В документе представлено описание алгоритма для предобработки входных данных задачи предсказании гипоксии.

Каждый объект представлял собой различный набор графиков двух типов “bpm” и “uterus”. Для передачи данных на вход сверточной нейронной сети была выбрана стратегия преобразования входных данных в картинку.

Алгоритм был написан в рамках курса “Нейросети в задачах цифрового анализа данных” группы М9124-01.04.02пми ДВФУ

Описание Алгоритм:
1.	На вход поступает папка объекта с двумя типами графиков формата csv в соответствующих папках: hypoxia и regular
2.	Графики в каждой папке сортируются по наименованию
3.	Поочередно берутся пары графиков разного типа, их значения нормализуются по формуле:
(value – value.mean()) / value.std(), где value np.array библиотеки numpy
4.	Проверяется размер графиков, если они содержат менее minimal_size_of_data=100 значений, то такая пара пропускается. (Предположение на неверность входных данных)
5.	Сравнивается размер графиков, меньший расширяется методом интерполяции np.interp() библиотеки numpy
6.	После каждый список данных графиков разделяется на чанки размером chunk_len = 1600
7.	Для каждого чанка проводится процедура уменьшения размерности downsample_data:
входной массив делится на группы по n=5 элементов, после чего каждая группа заменятся своим средним значением. Реализовано с помощью numpy: np.array(truncated_data).reshape(-1, n).mean(axis=1)
8.	Далее чанк преобразовывается в картинку с помощью библиотеки pyts, класса MarkovTransitionField.
9.	Если картинка не занимает все доступное пространство = chunk_len/n = 1600/5 = 320, то оставшиеся части заполняются нулями.
10.	Если в процессе количество чанков превышает line_limit = 16 или заканчиваются входные данные, программа приступает к этапу совмещения картинок.
11.	Если при построение картинок их набралось меньше line_limit, то недостающие картинки заменяются на повторения предыдущих в порядке добавления.
12.	Если картинок набралось больше line_limit, то мы оставляем только срез картинок от 0 до line_limit
13.	Складываем горизонтально картинки каждого типа отдельно с помощью функции библиотеки numpy – np.hstack(images[0]) 
14.	Складываем вертикально получившиеся картинки типов графиков с помощью numpy –np.vstack(images)
15.	Результат сжимаем с помощью matplotlib.pyplot и подаем на выход
